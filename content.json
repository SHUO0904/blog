{"meta":{"title":"HOME","subtitle":null,"description":null,"author":null,"url":"https://shuo0904.github.io/blog","root":"/blog/"},"pages":[],"posts":[{"title":"","slug":"正则表达式常用整理","date":"2019-11-11T08:02:31.315Z","updated":"2019-11-12T03:27:05.785Z","comments":true,"path":"2019/11/11/正则表达式常用整理/","link":"","permalink":"https://shuo0904.github.io/blog/2019/11/11/正则表达式常用整理/","excerpt":"","text":"title: 【Python】正则表达式常用整理date: 2019-11-11 16:02:31tags: 正则表达式 正则表达式（regular expression）是对字符串操作一种逻辑公式，用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，对字符串一种过滤逻辑。最简单正则表达式是普通字符串，可以匹配其自身。如，正则表达式‘hello’可以匹配字符串‘hello’ 正则表达式不是一个程序，是用于处理字符串的一种模式；使用时需使用支持正则表达式工具，如：Linux中的awk，sed，grep，或编程语言中的Perl，Python，Java等等 字符组:[字符组]，在同一个位置可能出现的各种字符组成一个字符组，在正则表达式中用[ ]表示；字符分为很多类，比如：数字，字母，标点等 正则 待匹配字符 匹配结果 说明 [0123456789] 8 True 在一个字符组里枚举合法的所有字符，字符组里的一个字符和“待匹配字符”相同都视为可以匹配 [0123456789] a False 由于字符组中没有“a”字符，无匹配结果 [0-9] 7 True 可以用 - 表示范围，[0-9]和[0123456789]是一个意思 [a-z] s True 匹配所有的小写字母 [A-Z] B True 匹配所有大写字母 [0-9a-fA-F] e True 匹配数字，大小写a~f，可用来验证十六进制字符 常用限定符 语法 说明 *? 重复任意次，但尽可能少重复 +？ 重复1次或更多次，但尽可能少重复 ？？ 重复0次或1次，尽可能少重复 {n,m}? 重复n到m次，但可能少重复 {n,}? 重复n次以上，但尽可能少重复 常用表达式全集 字 符 描述 \\ 将一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。如：“n”匹配字符“n”。”\\n”匹配一个换行符。“\\\\”匹配”\\“。“\\(”匹配“（”。 ^ 匹配输入字符串的开始位置。 $ 匹配输入字符串的结束位置。 * 匹配前面的子表达式零次或多次。如：zo* 能匹配“z”及“zoo”，* 等价于{0，} + 匹配前面的子表达式一次或多次。如：zo+ 能匹配”zo“及”zoo“，但不能匹配”z“。+等价于{1，} ？ 匹配前面的字表达式零次或一次。如：do(es)? 能匹配 does 或 does中的do。？等价于{0,1} {n} n是一个非负整数。匹配确定的n次。如：o{2} 不能匹配bob中的o，但能匹配 food 中的两个o {n,} n是一个非负整数。至少匹配n次。如：o{2，} 不能匹配 ‘Bob’中的‘o’，但能匹配到 ‘foooooood’中所有o。“o{1,}等价于“o+”。”o{0,}“等价于”o*“ {n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。如：”o{1,3}”将匹配“fooooooood”中前三个o。“o{0,1}”等价于“o?”。注意逗号和两个数之间不能有空格。 ？ 当该字符紧跟在任何一个其它限制符(*,+,?,{n},{n,},{n,m})后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。如：字符串”ooooo”，”o+?”将匹配单个”o”，而”o+”将匹配所有”o” . 匹配除 “\\n”之外的任何单个字符。要匹配包括“\\n”在内的任何字符，使用“(.|\\n)”的模式 (pattern） 匹配pattern并获取这一匹配 (?:pattern） 匹配pattern但不获取匹配结果，非获取匹配。如：industr(?:y|ies) 比 “industry|industries”简略 (?=pattern 正向肯定预查，任何匹配pattern的字符串开始匹配查找字符串。如：Window(?=95|98|NT|2000) 能匹配 Windows2000 中的 Windows，但不能匹配”Window3.1”中的”Windows“。在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern） 正向否定预查，任何不匹配pattern的字符串开始匹配查找字符串。如：Windows(?!95|98|NT|2000) 能匹配“Windows3.1”中的“Windows”，不能匹配“Windows2000”中的“Windows”。在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 (?&lt;=patt) 反向肯定预查，与正向肯定预查类似，只是方向相反。如：”(?&lt;95|98|NT|2000)Windows”能匹配”2000Windows”中的”Windows“，但不能匹配”3.1Windows”中的”Windows” (?&lt;!patt) 反向否定预查，与正向否定预查类似，只是方向相反。如：“(?&lt;95|98|NT|2000)Windows”能匹配”3.1Windows”中的”Windows”，但不能匹配”2000Windows”中的“Windows” x|y 匹配x或y。如：“z|food”能匹配”z”或”food”。”(z|f)food”则匹配”zood”或”food” [xyz] 字符集合。匹配所包含的任意一个字符。如，”[abc]”可匹配”plain”中的”a” [^xyz] 负值字符集合。 匹配未包含的任意字符。如：”[^abc]”可匹配”plain”中的”p” [a-z] 字符范围。匹配指定范围内的任意字符。如：”[a-z]”可以匹配”a”到”z”范围内的任意字符 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。如：”[^a-z]”可以匹配任何不在”a”到”z”范围内的任意字符 \\b 匹配一个单词边界，也就是单词和空格间的位置。如：”er\\b”可以匹配”never”中的”er”，不能匹配”verb”中的“er” \\B 匹配非单词边界。”er\\B”能匹配”verb”中的“er”，但不能匹配”never”中的”er” \\cx 匹配由x指明的控制字符。如：\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将C视为一个原义的”c”字符 \\d 匹配一个数字字符，等价于[0-9] \\D 匹配一个非数字字符，等价于[^0-9] \\f 匹配一个换页符，等价于\\x0c和\\cL \\n 匹配一个回车符，等价于\\x0d和\\cM \\r 匹配一个回车符，等价于\\x0d和\\cM \\s 匹配任何空白字符，包括空格、制表符、换页符等待，等价于[\\f\\n\\r\\t\\v] \\S 匹配任何非空白字符，等价于[^\\f\\n\\r\\t\\v] \\t 匹配一个制表符，等价于\\x09和\\cl \\v 匹配一个垂直制表符，等价于\\x0b和\\cK \\w 匹配包括下划线的任何单词字符，等价于“[A-Za-z0-9]” \\W 匹配任何非单词字符，等价于”[^A-Za-z0-9]” \\xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数长。如：”\\x41”匹配”A”，“\\x041”等价于”\\x04&amp;1”，可以使用ASCII编码 \\num 匹配num，其中num是一个正整数。对获取的匹配引用。如：”(.)\\1”匹配两个连续的相同字符 \\n 标识一个八进制转义值或一个向后引用。如果*n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 *nml* 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 **nm** 标识一个八进制转义值或一个向后引用。如果*nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm*。 \\un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。 用户名 /^[a-z0-9_-]{3,16}$/ 密码 /^[a-z0-9_-]{6,18}$/ 十六进制值 /^#?([a-f0-9]{6}|[a-f0-9]{3})$/ 电子邮箱 /^([a-z0-9_.-]+)@([\\da-z.-]+).([a-z.]{2,6})$//^[a-z\\d]+(.[a-z\\d]+)*@(\\da-z?)+(.{1,2}[a-z]+)+$/ URL /^(https?://)?([\\da-z.-]+).([a-z.]{2,6})([/\\w .-])/?$/ HTML 标签 /^&lt;([a-z]+)([^&lt;]+)(?:&gt;(.)&lt;/\\1&gt;|\\s+/&gt;)$/ 删除代码\\注释 (?&lt;!http:|\\S)//.*$ Unicode编码中的汉字范围 /^[\\u2E80-\\u9FFF]+$/ 参考链接 http://tool.oschina.net/uploads/apidocs/jquery/regexp.html","categories":[],"tags":[]},{"title":"爬虫常用解析","slug":"爬虫常用解析","date":"2019-11-10T10:52:30.000Z","updated":"2019-11-10T12:18:45.824Z","comments":true,"path":"2019/11/10/爬虫常用解析/","link":"","permalink":"https://shuo0904.github.io/blog/2019/11/10/爬虫常用解析/","excerpt":"","text":"Xpath解析 (lxml) 使用前，需进行安装lxml，pip install lxml 常用： wiki123456789101112131415161718nodename # 选取nodename节点所有子节点 xpath(&apos;//div&apos;) # 选取了所有div节点 / # 从根节点选取 xpath(&apos;/div&apos;) # 从根节点上选取div节点 // # 选取所有的当前节点,不考虑位置 xpath(&apos;//div&apos;) # 选取所有的div节点 . # 选取当前节点 xpath(&apos;./div&apos;) # 选取当前节点下的div节点 .. # 选取当前节点父节点 xpath(&apos;..&apos;) #回到上一个节点 @ # 选取属性 xpath(&apos;//@class&apos;) #选取所有的class属性//div[@class=&apos;song&apos;] # 找到class属性值为song的div标签//div[@class=&apos;tang&apos;]/url/li[2]/a # 找到class属性值为tang的div的直系子标签url下第二个标签li直系子标签a//a[@href=&apos;&apos;and @class=&apos;du&apos;] # 找到href属性值为空且class属性值为du的a标签//div[contains(@class, &apos;ng&apos;)] # 模糊查询//div[starts-with(@class,&apos;ta&apos;)] # 模糊查询//div[@class=&apos;song&apos;]/p[1]/text() # / 表示获取某个标签下的文本内容//div[@class=&apos;tang&apos;]//text() # // 表示获取某个标签下的文本内容和所有子标签下的文本内容//div[@class=&apos;tang&apos;]//li[2]/a/@href #取属性 函数 用法 解释starts-with xpath(‘//div[starts-with(@id,”ma”)]‘) # 选取id值以ma开头的div节点contains xpath(‘//div[contains(@id,”ma”)]‘) # 选取id值包含ma的div节点text() xpath(‘//div[contains(text(),”ma”)]‘) # 选取节点文本包含ma的div节点 如： 1234567891011# 先导包from lxml import etree# 将html文档或者xml文档转换成一个etree对象，然后调用对象中的方法查找指定的节点# 1. 本地文件tree = etree.parse(文件名)tree.xpath(\"xpath表达式\")# 2. 网络数据tree = etree.HTML(网页内容字符串)tree.xpath(\"xpath表达式\") Beautiful Soup 解析 使用前，需安装beautifulsoup，pip install beautifulsoup4 Beautiful Soup 支持python标准库中的HTML解析器，也可使用第三方解析器，如lxml 常用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# 根据标签名查找 - soup.a 只能找到第一个符合要求的标签# 获取属性 - soup.a.attrs 获取a所有的属性和属性值，返回一个字典 - soup.a.attrs[&apos;href&apos;] 获取href属性 - soup.a[&apos;href&apos;] 也可简写为这种形式# 获取内容 - soup.a.string - soup.a.text - soup.a.get_text() 注意:如果标签还有标签，那么string获取到的结果为None，而其它两个，可以获取文本内容# find：找到第一个符合要求的标签 - soup.find(&apos;a&apos;) 找到第一个符合要求的 - soup.find(&apos;a&apos;, title=&quot;xxx&quot;) - soup.find(&apos;a&apos;, alt=&quot;xxx&quot;) - soup.find(&apos;a&apos;, class_=&quot;xxx&quot;) - soup.find(&apos;a&apos;, id=&quot;xxx&quot;)# find_all：找到所有符合要求的标签 - soup.find_all(&apos;a&apos;) - soup.find_all([&apos;a&apos;,&apos;b&apos;]) 找到所有的a和b标签 - soup.find_all(&apos;a&apos;, limit=2) 限制前两个# 根据选择器选择指定的内容 select:soup.select(&apos;#feng&apos;) - 常见的选择器：标签选择器(a)、类选择器(.)、id选择器(#)、层级选择器 - 层级选择器： div .dudu #lala .meme .xixi 下面好多级 div &gt; p &gt; a &gt; .lala 只能是下面一级 注意:select选择器返回永远是列表，需要通过下标提取指定的对象------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------------------from bs4 import BeautifulSoupsoup=BeautifulSoup(html_doc,&apos;lxml&apos;)#字符串：即标签名print(soup.find_all(&apos;b&apos;))#正则表达式import reprint(soup.find_all(re.compile(&apos;^b&apos;))) #找出b开头的标签，结果有body和b标签# 列表：如果传入列表参数,Beautiful Soup会将与列表中任一元素匹配的内容返回.下面代码找到文档中所有&lt;a&gt;标签和&lt;b&gt;标签:print(soup.find_all([&apos;a&apos;,&apos;b&apos;]))#True：可以匹配任何值,下面代码查找到所有的tag,但是不会返回字符串节点print(soup.find_all(True))for tag in soup.find_all(True): print(tag.name)#方法:如果没有合适过滤器,那么还可以定义一个方法,方法只接受一个元素参数 ,如果这个方法返回 True 表示当前元素匹配并且被找到,如果不是则反回 False-------------------------------------------------------------------------------------------------注意：关键字是class_，class_=value,value可以是五种选择器之一print(soup.find_all(&apos;a&apos;,class_=&apos;sister&apos;)) # 查找类为sister的a标签print(soup.find_all(&apos;a&apos;,class_=&apos;sister ssss&apos;)) # 查找类为sister和sss的a标签，顺序错误也匹配不成功print(soup.find_all(class_=re.compile(&apos;^sis&apos;))) # 查找类为sister的所有标签-------------------------------------------------------------------------------------------------#attrsprint(soup.find_all(&apos;p&apos;,attrs=&#123;&apos;class&apos;:&apos;story&apos;&#125;))-------------------------------------------------------------------------------------------------#text 值可以是：字符，列表，True，正则print(soup.find_all(text=&apos;Elsie&apos;))print(soup.find_all(&apos;a&apos;,text=&apos;Elsie&apos;))-------------------------------------------------------------------------------------------------#limit参数：如果文档树很大那么搜索会很慢.如果我们不需要全部结果,可以使用 limit 参数限制返回结果的数量.效果与SQL中的limit关键字类似,当搜索到的结果数量达到 limit 的限制时,就停止搜索返回结果print(soup.find_all(&apos;a&apos;,limit=2))-------------------------------------------------------------------------------------------------#recursive 调用tag的 find_all() 方法时,Beautiful Soup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 recursive=Falseprint(soup.html.find_all(&apos;a&apos;))print(soup.html.find_all(&apos;a&apos;,recursive=False))-------------------------------------------------------------------------------------------------#tag：像调用 find_all() 一样调用tag find_all() 几乎是Beautiful Soup中最常用的搜索方法,所以我们定义了它的简写方法. BeautifulSoup 对象和 tag 对象可以被当作一个方法来使用~# 下面两行代码是等价的:soup.find_all(&quot;a&quot;)soup(&quot;a&quot;)# 这两行代码也是等价的:soup.title.find_all(text=True)soup.title(text=True)-------------------------------------------------------------------------------------------------#find_all() 方法将返回文档中符合条件的所有tag,尽管有时候我们只想得到一个结果.比如文档中只有一个&lt;body&gt;标签,那么使用 find_all() 方法来查找&lt;body&gt;标签就不太合适, 使用 find_all 方法并设置 limit=1 参数不如直接使用 find() 方法soup.find_all(&apos;title&apos;, limit=1)# [&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;]soup.find(&apos;title&apos;)# &lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;#find() 方法直接返回结果.find_all() 方法没有找到目标是返回空列表, find() 方法找不到目标时,返回 Noneprint(soup.find(&quot;nosuchtag&quot;))# None 如： 12345678910from bs4 import BeautifulSoup# 转化本地文件soup = BeautifulSoup(open('本地文件'), 'lxml')# 转化网络文件soup = BeautifulSoup('字符串类型或者字节类型', 'lxml')# 从文档中获取所有文字内容:print(soup.get_text()) 正则表达式解析 使用正则表达式进行提起，如： 1234pattern = re.compile('&lt;dd&gt;.*?board-index.*?&gt;(\\d+)&lt;/i&gt;.*?src=\"(.*?)\".*?name\"&gt;&lt;a' +'.*?&gt;(.*?)&lt;/a&gt;.*?star\"&gt;(.*?)&lt;/p&gt;.*?releasetime\"&gt;(.*?)&lt;/p&gt;' +'.*?integer\"&gt;(.*?)&lt;/i&gt;.*?fraction\"&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;', re.S)items = re.findall(pattern, html)","categories":[],"tags":[]},{"title":"【Python】 requests请求","slug":"requests-python","date":"2019-10-30T12:25:22.000Z","updated":"2019-11-01T09:41:38.470Z","comments":true,"path":"2019/10/30/requests-python/","link":"","permalink":"https://shuo0904.github.io/blog/2019/10/30/requests-python/","excerpt":"","text":"requests.post requests.post() 进行POST请求，传入报文的参数有2个，一个是data，一个是json 常见的form表单可以直接使用data参数进行报文提交，data的对象是python中的字典类型 最新存在payload报文，是一种json格式的报文，传入的报文对象需格式 12request.post(url,data=json.dumps(data))request.post(url,json=data) //json参数会自动将字典类型的对象转换为json格式 若data传递的参数为字符串，如json.dumps(payload),则request对参数进行url编码，所以data传字符串时，需要在header中指定Content-Type，如headers={“Content-Type”: “application/json”} 如果data传递的是字典、元组组成的列表或列表作为值的字典，则request对参数进行url编码，Content-Type的值为application/x-www-form-urlencoded content-type详解 http协议是建立在tcp/ip协议之上的应用层协议，主要包括三个部分，状态行，头部信息，消息主体。对应一个Http请求就是：请求行，请求头，请求体。 协议规定post提交数据，必须包含在消息主体中entiy-body中，但是协议并没有规定数据使用什么编码方式，开发者可以自己决定消息主体的格式。 数据发送出去后，需要接收 服务端解析成功，一般服务端会根据content-type 字段获取参数是怎么编码的，然后对应去解码 application/x-www-form-urlencoded,在最开始的请求方式中，请求参数都是放在url中，表单提交的时候，是以key=&amp;value=的方式写在url后面，是浏览器表单提交的默认方式 multipart/form-data,此种方式多用于文件上传，表单数据都保存在http的正文部分，各个表单项之间用bounday分开 application/json,与服务端消息主体是序列化的json字符串。目前比较常用，且spring对这个content-type上传的数据有很好的支持，对RestApi有很好的适配","categories":[],"tags":[]},{"title":"REST 和 RESTful API","slug":"api","date":"2019-10-29T11:48:08.000Z","updated":"2019-10-30T12:23:16.457Z","comments":true,"path":"2019/10/29/api/","link":"","permalink":"https://shuo0904.github.io/blog/2019/10/29/api/","excerpt":"","text":"Rest Rest是 REpresentational State Transfer，即表现层状态转化。 “表现层”指“资源”的“表现层“。把“资源”具体呈现出来的形式，叫做它的“表现层”。 所谓”资源“，指网络中一个实体或者说网络上的一个具体信息。如:文本、图片等。 所谓“转移”，代表客户端和服务器一个互动过程，过程中，涉及数据和状态的变化。 互联网通信协议HTTP协议，是一个无状态的协议。这意味着，所有的状态都保存在服务器端。若客户端想要操作服务器，需通过某种手段，让服务换发生“状态转化”(State Transfer)。而这种转化是建立在表现层之上，叫做“表现层状态转化” 客户端用到的手段，是HTTP协议中的四个操作方式的动词：GET、POST、PUT、DELETE，分别对应四种基本操作，GET用来获取资源，POST用来新建资源(可用户更新资源)，PUT用来更新资源，DELETE用来删除资源。URL定位资源，直接映射到HTTP中已实现的GET，POST，Delete，PUT方法 REST成熟度的四个层次 第一个层次的web服务，是使用HTTP作为传输方式，实际上远程方法调用(RPC)的具体形式，SOAP和XML-RPC属于此类 第二个层次的web服务，引入了资源的概念，每个资源有对应的标识符和表达。 第三个层次的web服务，使用不同的HTTP方法进行不同 操作，并且使用HTTP状态码表示不同的结果。如:HTTP和Get方法来获取资源、DELETE方法来删除资源 第四个层次的web服务，使用HATEOAS,在资源的表达中包含了链接信息。客户端可根据链接发现可执行的动作 Restful Api REST描述的是网络中client和server的一种交互形式；RESTful API是一种REST风格的网络 URL的根路径，如：http://api.****.com/v1 需要有api版本信息，如：v1 URL中使用名词指定资源，不用动词，且推荐使用复数，如：http://api.****.com/v1/books 使用HTTP协议里的动词来实现资源的添加，修改，删除，更新。包括，GET、POST、PUT、DELETE 使用正确的HTTP Status Code返回状态码，包括：2××=success(成功)、3××=Redirect(重定向)、4××=客户端错误、5××=服务端错误 综上，RESTful API是无状态，请求URL=动作(GET/POST/PUT/DELETE)+资源，响应使用精确的状态码和JSON格式数据","categories":[],"tags":[]},{"title":"Git 介绍和使用","slug":"Git","date":"2019-10-26T10:01:58.000Z","updated":"2019-10-27T08:33:22.023Z","comments":true,"path":"2019/10/26/Git/","link":"","permalink":"https://shuo0904.github.io/blog/2019/10/26/Git/","excerpt":"","text":"Git 介绍 git是分布式版本控制系统，SVN是集中式版本控制系统 集中式版本控制系统，版本库是集中存放在中央服务器，每次编写、修改、提取、上传等操作，首先需从中央服务器取得最新的版本，后进行编写等，完成后重新推送到中央服务器。且必须联网才能工作。 分布式版本控制系统，无中央服务器，项目组内成员每人的电脑是一个完整的版本库。如：A在自己电脑改了文件C，B也在自己电脑上改了文件C，此时，A和B只需把各自修改推送给对方，就可以看见对方的修改。 Git 安装 搜索git，进入(https://www.git-scm.com/download/)，点击下载 点击安装包，点击“下一步”，安装时选择“Use git from git bash only…”，其它默认 安装完后，检查是否已经配置环境变量 配置git用户名和邮箱 1234右键-git bashgit config --global user.name \"用户名\"git config --global user.email \"邮箱\"检查是否配置成功，查看C:\\User\\电脑登录名\\.gitconfig 为了在本地和远程仓库之间进行 免秘钥登录，可以配置ssh(具体可在网站搜索)) Git 常用操作 本地项目 -远程项目关联 12git init //本地项目文件夹右建-gitbashgit remote add origin github仓库名地址 第一次将本地代码发布到远程仓库 123git add . /git add file.txt //本地文件-本地暂存区,add 可以添加多个文件git commit -m '注释内容' //暂存区-本地分支仓库-默认master)git push -u origin master 第一次下载从远程仓库下载项目 1git clone 远程仓库.git 将本地代码提交到远程仓库 1234在当前项目文件夹-右键-git bashgit add .git commit -m '提交到分支' //git push origin master 将远程仓库的内容拉取到本地仓库分支 1git pull 12345678910git status //查看仓库的当前状态git log --pretty=oneline //查看历史记录commit_idgit reset --hard commit_id //返回到commit_id版本git reflog //记录命令历史git checkout -b dev分支 //创建dev分支并切换到dev分支git branch //列出所有分支git checkout master //切换到master分支git switch -c dev //创建并切换到新的dev分支git merge dev // 合并指定分支到当前分支git branch -d dev //删除dev分支 工作区(Working Directory)：项目文件夹 版本库(Repository):工作区有个隐藏的.git,是git的版本库。版本库中stage(或者叫index)的暂存区 把文件往git版本库里添加的时候，是分两步执行的： 用git add把文件添加进去，实际上就是把文件修改添加到暂存区 用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支","categories":[],"tags":[]},{"title":"关于我","slug":"about-me","date":"2019-10-19T09:06:41.000Z","updated":"2019-10-19T09:17:46.233Z","comments":true,"path":"2019/10/19/about-me/","link":"","permalink":"https://shuo0904.github.io/blog/2019/10/19/about-me/","excerpt":"","text":"平时喜欢整理个人博客，逛逛技术论坛。 了解一些 前端 基本概念和 Python 的简单用法。","categories":[],"tags":[]},{"title":"关于转载","slug":"copyright-reprinted","date":"2019-10-19T08:07:51.000Z","updated":"2019-10-19T09:05:06.844Z","comments":true,"path":"2019/10/19/copyright-reprinted/","link":"","permalink":"https://shuo0904.github.io/blog/2019/10/19/copyright-reprinted/","excerpt":"","text":"尊重原创，从我做起 😂 相互学习，欢迎转载，转载时请加上原文链接！","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-10-14T10:59:22.425Z","updated":"2019-10-14T10:59:22.425Z","comments":true,"path":"2019/10/14/hello-world/","link":"","permalink":"https://shuo0904.github.io/blog/2019/10/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}